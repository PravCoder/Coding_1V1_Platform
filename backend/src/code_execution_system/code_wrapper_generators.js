const generateOutputHandling = require("./output_handling");

const dataTypeSystem = require("./data_type_system");


/* 
userCode = what the user sees code generated by templateGenerators, the template code

But what the user sees code is not enough to run the code, we nede to add code like getting the input parameters so the user doesn't have to like leetcode. 
We also need to add code to print the output of the code, so the user doesn't have to print output in correct format like leetcode.
*/
const codeWrappers = {

    python: (problem, userCode) => {  // given a problem and userCode (what the user sees)
        const {function_name, parameters} = problem;

        // for every parameter of this problem create a string line of code that creates a variable
        // that stores that input-param as its data structure type inthe code, (in the background user doesnt see)
        // ex, input_data["nums"] real python array , input_data["target"] real python int.
        const inputParsingCode = parameters.map(param => {
            return `${param.name} = input_data["${param.name}"]`;
        }).join("\n");

        // create a func-call string that just calls the problem function at the end
        const function_call = `${function_name}(${parameters.map(p => p.name).join(', ')})`;

        // get the line of code that prints the output based on the language 
        const output_handle = generateOutputHandling("python", problem.return_type);

        // based on input parsing code of this problem's parameteres, and users code, the function call and output printing wrap the final code
        const temp = `import sys
import json

# Input parsing
input_data = json.loads(sys.stdin.read())
${inputParsingCode}

# User's Solution
${userCode}

# Execute and output
result = ${function_call}
${output_handle}`;

        return temp; // note: the user returns the result object and the code-execution-systems responsiblity to print it, in the wrapped code using the function call

    },

    cpp: (problem, userCode) => {
        const {function_name, parameters} = problem;

        // Generate input parsing for C++
        const inputParsingCode = parameters.map(param => {
            const cppType = dataTypeSystem[param.type]?.cpp || param.type;
            
            if (cppType.includes('vector<vector<')) {
                // 2D vector parsing
                return `    ${cppType} ${param.name};
        int rows, cols;
        cin >> rows >> cols;
        ${param.name}.resize(rows, vector<int>(cols));
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < cols; j++) {
                cin >> ${param.name}[i][j];
            }
        }`;
            } else if (cppType.includes('vector<')) {
                // 1D vector parsing
                return `    ${cppType} ${param.name};
        int size;
        cin >> size;
        ${param.name}.resize(size);
        for(int i = 0; i < size; i++) {
            cin >> ${param.name}[i];
        }`;
            } else {
                // Simple type parsing
                return `    ${cppType} ${param.name};
        cin >> ${param.name};`;
            }
        }).join("\n");

        // Determine if user code is a class or standalone function
        const isClass = userCode.includes('class Solution') || userCode.includes('class ');
        
        let function_call;
        if (isClass) {
            function_call = `solution.${function_name}(${parameters.map(p => p.name).join(', ')})`;
        } else {
            function_call = `${function_name}(${parameters.map(p => p.name).join(', ')})`;
        }

        // get code that prints output for c++
        const output_handle = generateOutputHandling("cpp", problem.return_type);

        const temp = `
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <unordered_map>
using namespace std;

${userCode}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    // Input parsing
${inputParsingCode}
    
    // Execute solution
    ${isClass ? 'Solution solution;' : ''}
    auto result = ${function_call};
    
    // Output handling
    ${output_handle}
    
    return 0;
}`;

        return temp;
    },

    java: (problem, userCode) => {

    }

}




/* 

---COMPLETE WRAPPED CODE EXAMPLE C+++---
#include <iostream>
    #include <vector>
    #include <string>
    #include <algorithm>
    #include <unordered_map>
    using namespace std;

    
class Solution {
    public:
        vector<int> twoSum(vector<int> nums, int target) {
            // Your code here
            return {}; 
        }
};


    int main() {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        
        // Input parsing
        vector<int> nums;
        int size;
        cin >> size;
        nums.resize(size);
        for(int i = 0; i < size; i++) {
            cin >> nums[i];
        }
    int target;
        cin >> target;
        
        // Execute solution
        Solution solution;
        auto result = solution.twoSum(nums, target);
        
        // Output handling
        for(int i = 0; i < result.size(); i++) {
        cout << result[i];
        if(i < result.size() - 1) cout << " ";
    }
        
        return 0;
    }

*/


module.exports = codeWrappers;
